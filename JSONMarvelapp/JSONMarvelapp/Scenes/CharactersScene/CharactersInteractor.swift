//
//  CharactersInteractor.swift
//  JSONMarvelapp
//
//  Created by Iván Díaz Molina on 2/12/20.
//  Copyright (c) 2020 IDIAZM. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CharactersBusinessLogic {
    func setupView()
    func didSelectedItemAt(index: Int)
    func getCharactersCount() -> Int
    func getCharacterCellFor(index: Int) -> Characters.Models.CharacterCellModel
}

protocol CharactersDataStore {
    var serie: Serie? { get set }
    var characters: [Actor]? { get set }
    var selectedCharacter: Actor? { get set }
}

class CharactersInteractor: CharactersBusinessLogic, CharactersDataStore {
    
    var presenter: CharactersPresentationLogic?
    var worker: CharactersWorker?
    
    var serie: Serie?
    var characters: [Actor]?
    var selectedCharacter: Actor?
    
    func setupView() {

        worker = CharactersWorker()
        
        // 1. check serie object
        guard let serie = serie else {
            return
        }
        
        // 2. load character of serie selected
        loadCharacters(for: serie)
        
        // 3. create response
        let response = Characters.SetupView.Response(title: "characters.title".localized)
                
        // 4. fire setupView
        presenter?.setupView(response: response)
    }
    
    func didSelectedItemAt(index: Int) {
        
        guard let character = characters?.getElement(index) else { return }
        
        selectedCharacter = character
        
        let response = Characters.DidSelectedItem.Response(actor: selectedCharacter)
        
        presenter?.presentDetails(response: response)
    }
    
    func getCharactersCount() -> Int {
        return characters?.count ?? 0
    }
    
    func getCharacterCellFor(index: Int) -> Characters.Models.CharacterCellModel {
        guard let actor = characters?.getElement(index) else { return Characters.Models.CharacterCellModel() }
        return Characters.Models.CharacterCellModel(character: actor)
    }
    
    // MARK: private methods
    fileprivate func loadCharacters(for serie: Serie) {
        
        presenter?.displayLoading(true)
        
        
        let deadlineTime = DispatchTime.now() + 1
        DispatchQueue.main.asyncAfter(deadline: deadlineTime) { [weak self] in
            self?.worker?.getCharacters(for: serie, completion: { [weak self] (characters, error) in
                            
                self?.characters = characters
                
                guard let count = characters?.count else {
                    self?.presenter?.presentEmptyView()
                    return
                }
                
                count == 0 ? self?.presenter?.presentEmptyView() : self?.presenter?.presentCharacters()
                
                self?.presenter?.displayLoading(false)
            })
        }
    }
}
